diff -Naur quake_sdl/cd_nacl.c quake_nacl/cd_nacl.c
--- quake_sdl/cd_nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ quake_nacl/cd_nacl.c	2009-03-02 17:15:23.757052000 -0800
@@ -0,0 +1,29 @@
+/*
+  The NaCl version of Quake does not support CDAudio, so just provide stubs
+*/
+
+
+#include "quakedef.h"
+
+void CDAudio_Stop() {
+}
+
+void CDAudio_Pause() {
+}
+
+void CDAudio_Resume() {
+}
+
+void CDAudio_Update() {
+}
+
+void CDAudio_Play(byte track, qboolean looping) {
+}
+
+int CDAudio_Init() {
+  return -1;
+}
+
+void CDAudio_Shutdown() {
+}
+
diff -Naur quake_sdl/cd_sdl.c quake_nacl/cd_sdl.c
--- quake_sdl/cd_sdl.c	2008-10-15 18:07:24.678595000 -0700
+++ quake_nacl/cd_sdl.c	2009-03-02 17:15:23.773104000 -0800
@@ -5,10 +5,14 @@
   Mark Baker <homer1@together.net>
 */
 
-#include <SDL.h>
-
 #include "quakedef.h"
 
+//#define HAVE_SDL_CD
+
+#if defined(HAVE_SDL_CD)
+
+#include <SDL.h>
+
 static qboolean cdValid = false;
 static qboolean initialized = false;
 static qboolean enabled = true;
@@ -221,3 +225,28 @@
 	}
 }
 
+#else
+
+void CDAudio_Stop() {
+}
+
+void CDAudio_Pause() {
+}
+
+void CDAudio_Resume() {
+}
+
+void CDAudio_Update() {
+}
+
+void CDAudio_Play(byte track, qboolean looping) {
+}
+
+int CDAudio_Init() {
+  return -1;
+}
+
+void CDAudio_Shutdown() {
+}
+
+#endif
diff -Naur quake_sdl/cl_main.c quake_nacl/cl_main.c
--- quake_sdl/cl_main.c	2008-10-15 18:07:24.692586000 -0700
+++ quake_nacl/cl_main.c	2009-03-02 17:15:23.828065000 -0800
@@ -647,7 +647,9 @@
 			break;
 		
 		cl.last_received_message = realtime;
-		CL_ParseServerMessage ();
+		if (-1 == CL_ParseServerMessage ())
+			return -1;
+
 	} while (ret && cls.state == ca_connected);
 	
 	if (cl_shownet.value)
diff -Naur quake_sdl/cl_parse.c quake_nacl/cl_parse.c
--- quake_sdl/cl_parse.c	2008-10-15 18:07:24.697576000 -0700
+++ quake_nacl/cl_parse.c	2009-03-02 17:15:23.835090000 -0800
@@ -717,7 +717,7 @@
 CL_ParseServerMessage
 =====================
 */
-void CL_ParseServerMessage (void)
+int CL_ParseServerMessage (void)
 {
 	int			cmd;
 	int			i;
@@ -788,6 +788,7 @@
 			
 		case svc_disconnect:
 			Host_EndGame ("Server disconnected\n");
+			return -1;
 
 		case svc_print:
 			Con_Printf ("%s", MSG_ReadString ());
@@ -959,5 +960,6 @@
 			break;
 		}
 	}
+	return 0;
 }
 
diff -Naur quake_sdl/client.h quake_nacl/client.h
--- quake_sdl/client.h	2008-10-15 18:07:36.939559000 -0700
+++ quake_nacl/client.h	2009-03-02 17:15:25.489875000 -0800
@@ -352,7 +352,7 @@
 //
 // cl_parse.c
 //
-void CL_ParseServerMessage (void);
+int CL_ParseServerMessage (void);
 void CL_NewTranslation (int slot);
 
 //
diff -Naur quake_sdl/common.c quake_nacl/common.c
--- quake_sdl/common.c	2008-10-15 18:07:24.706574000 -0700
+++ quake_nacl/common.c	2009-03-02 17:15:23.876071000 -0800
@@ -431,9 +431,6 @@
 ============================================================================
 */
 
-#ifdef SDL
-#include "SDL_byteorder.h"
-#endif
 
 qboolean        bigendien;
 
@@ -1128,34 +1125,14 @@
 */
 void COM_Init (char *basedir)
 {
-	byte    swaptest[2] = {1,0};
-
-// set the byte swapping variables in a portable manner 
-#ifdef SDL
-	// This is necessary because egcs 1.1.1 mis-compiles swaptest with -O2
-	if ( SDL_BYTEORDER == SDL_LIL_ENDIAN )
-#else
-	if ( *(short *)swaptest == 1)
-#endif
-	{
-		bigendien = false;
-		BigShort = ShortSwap;
-		LittleShort = ShortNoSwap;
-		BigLong = LongSwap;
-		LittleLong = LongNoSwap;
-		BigFloat = FloatSwap;
-		LittleFloat = FloatNoSwap;
-	}
-	else
-	{
-		bigendien = true;
-		BigShort = ShortNoSwap;
-		LittleShort = ShortSwap;
-		BigLong = LongNoSwap;
-		LittleLong = LongSwap;
-		BigFloat = FloatNoSwap;
-		LittleFloat = FloatSwap;
-	}
+	/* Native Client is always little endian */
+	bigendien = false;
+	BigShort = ShortSwap;
+	LittleShort = ShortNoSwap;
+	BigLong = LongSwap;
+	LittleLong = LongNoSwap;
+	BigFloat = FloatSwap;
+	LittleFloat = FloatNoSwap;
 
 	Cvar_RegisterVariable (&registered);
 	Cvar_RegisterVariable (&cmdline);
diff -Naur quake_sdl/crc.c quake_nacl/crc.c
--- quake_sdl/crc.c	2008-10-15 18:07:24.714570000 -0700
+++ quake_nacl/crc.c	2009-03-02 17:15:23.895070000 -0800
@@ -78,4 +78,5 @@
 unsigned short CRC_Value(unsigned short crcvalue)
 {
 	return crcvalue ^ CRC_XOR_VALUE;
-}
\ No newline at end of file
+}
+
diff -Naur quake_sdl/d_ifacea.h quake_nacl/d_ifacea.h
--- quake_sdl/d_ifacea.h	2008-10-15 18:07:36.967558000 -0700
+++ quake_nacl/d_ifacea.h	2009-03-02 17:15:25.577866000 -0800
@@ -38,7 +38,7 @@
 #define	CYCLE	128
 
 // !!! if this is changed, it must be changed in r_shared.h too !!!
-#define	MAXHEIGHT	1024
+#define	MAXHEIGHT	2048
 
 // !!! if this is changed, it must be changed in quakedef.h too !!!
 #define CACHE_SIZE	32		// used to align key data structures
diff -Naur quake_sdl/host.c quake_nacl/host.c
--- quake_sdl/host.c	2008-10-15 18:07:24.835571000 -0700
+++ quake_nacl/host.c	2009-03-02 17:15:24.241007000 -0800
@@ -108,7 +108,8 @@
 	else
 		CL_Disconnect ();
 
-	longjmp (host_abortserver, 1);
+	// longjmp (host_abortserver, 1);
+
 }
 
 /*
@@ -637,8 +638,10 @@
 	static double		time3 = 0;
 	int			pass1, pass2, pass3;
 
-	if (setjmp (host_abortserver) )
-		return;			// something bad happened, or the server disconnected
+
+	for (;;) {
+//	if (setjmp (host_abortserver) )
+//		return;			// something bad happened, or the server disconnected
 
 // keep the random time dependent
 	rand ();
@@ -690,7 +693,8 @@
 // fetch results from server
 	if (cls.state == ca_connected)
 	{
-		CL_ReadFromServer ();
+		if (CL_ReadFromServer () == -1)
+			continue;
 	}
 
 // update video
@@ -724,6 +728,8 @@
 	}
 	
 	host_framecount++;
+	break;
+	}
 }
 
 void Host_Frame (float time)
diff -Naur quake_sdl/net_dgrm.c quake_nacl/net_dgrm.c
--- quake_sdl/net_dgrm.c	2008-10-15 18:07:24.888580000 -0700
+++ quake_nacl/net_dgrm.c	2009-03-02 17:15:24.372998000 -0800
@@ -19,6 +19,11 @@
 */
 // net_dgrm.c
 
+#include "quakedef.h"
+
+//#define HAVE_NET_DGRM
+#if defined(HAVE_NET_DGRM)
+
 // This is enables a simple IP banning mechanism
 #define BAN_TEST
 
@@ -52,7 +57,6 @@
 #endif
 #endif	// BAN_TEST
 
-#include "quakedef.h"
 #include "net_dgrm.h"
 
 // these two macros are to make the code more readable
@@ -1388,3 +1392,53 @@
 				break;
 	return ret;
 }
+#else
+
+int Datagram_Init (void) {
+  return -1;
+}
+
+void Datagram_Listen (qboolean state) {
+}
+
+void Datagram_SearchForHosts (qboolean xmit) {
+}
+
+qsocket_t *Datagram_Connect (char *host) {
+  return NULL;
+}
+
+qsocket_t *Datagram_CheckNewConnections (void) {
+  return NULL;
+}
+
+int	Datagram_GetMessage (qsocket_t *sock) {
+  return -1;
+}
+
+int Datagram_SendMessage (qsocket_t *sock, sizebuf_t *data) {
+  return -1;
+}
+
+int Datagram_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data) {
+  return -1;
+}
+
+qboolean Datagram_CanSendMessage (qsocket_t *sock) {
+  return 0;
+}
+
+qboolean Datagram_CanSendUnreliableMessage (qsocket_t *sock)
+{
+	return false;
+}
+
+void Datagram_Close (qsocket_t *sock) {
+}
+
+void Datagram_Shutdown (void) {
+}
+
+
+#endif
+
diff -Naur quake_sdl/net_udp.c quake_nacl/net_udp.c
--- quake_sdl/net_udp.c	2008-10-15 18:07:24.921573000 -0700
+++ quake_nacl/net_udp.c	2009-03-02 17:15:24.484945000 -0800
@@ -19,9 +19,13 @@
 */
 // net_udp.c
 
-#include "quakedef.h"
+//#define HAVE_NET_UDP
 
+#include "quakedef.h"
 #include <sys/types.h>
+
+#if defined(HAVE_NET_UDP)
+
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <netdb.h>
@@ -413,3 +417,81 @@
 }
 
 //=============================================================================
+
+#else
+
+int UDP_Init (void) {
+  return -1;
+}
+
+void UDP_Shutdown (void) {
+}
+
+void UDP_Listen (qboolean state) {
+}
+
+int UDP_OpenSocket (int port) {
+  return -1;
+}
+
+int UDP_CloseSocket (int socket) {
+  return -1;
+}
+
+int UDP_Connect (int socket, struct qsockaddr *addr) {
+  return 0;
+}
+
+int UDP_CheckNewConnections (void) {
+  return -1;
+}
+
+int UDP_Read (int socket, byte *buf, int len, struct qsockaddr *addr) {
+  return -1;
+}
+
+int UDP_MakeSocketBroadcastCapable (int socket) {
+  return -1;
+}
+
+int UDP_Broadcast (int socket, byte *buf, int len) {
+  return -1;
+}
+
+int UDP_Write (int socket, byte *buf, int len, struct qsockaddr *addr) {
+  return -1;
+}
+
+char *UDP_AddrToString (struct qsockaddr *addr) {
+  return NULL;
+}
+
+int UDP_StringToAddr (char *string, struct qsockaddr *addr) {
+  return -1;
+}
+
+int UDP_GetSocketAddr (int socket, struct qsockaddr *addr) {
+  return -1;
+}
+
+int UDP_GetNameFromAddr (struct qsockaddr *addr, char *name) {
+  return -1;
+}
+
+int UDP_GetAddrFromName(char *name, struct qsockaddr *addr) {
+  return -1;
+}
+
+int UDP_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2) {
+  return -1;
+}
+
+int UDP_GetSocketPort (struct qsockaddr *addr) {
+  return -1;
+}
+
+int UDP_SetSocketPort (struct qsockaddr *addr, int port) {
+  return 0;
+}
+
+#endif
diff -Naur quake_sdl/r_local.h quake_nacl/r_local.h
--- quake_sdl/r_local.h	2008-10-15 18:07:37.084563000 -0700
+++ quake_nacl/r_local.h	2009-03-02 17:15:25.965858000 -0800
@@ -313,4 +313,5 @@
 void R_SplitEntityOnNode2 (mnode_t *node);
 void R_MarkLights (dlight_t *light, int bit, mnode_t *node);
 
-#endif
\ No newline at end of file
+#endif
+
diff -Naur quake_sdl/r_shared.h quake_nacl/r_shared.h
--- quake_sdl/r_shared.h	2008-10-15 18:07:37.087557000 -0700
+++ quake_nacl/r_shared.h	2009-03-02 17:15:25.973867000 -0800
@@ -30,8 +30,8 @@
 #define MAXWORKINGVERTS	(MAXVERTS+4)	// max points in an intermediate
 										//  polygon (while processing)
 // !!! if this is changed, it must be changed in d_ifacea.h too !!!
-#define	MAXHEIGHT		1024
-#define	MAXWIDTH		1280
+#define	MAXHEIGHT		2048
+#define	MAXWIDTH		4096
 #define MAXDIMENSION	((MAXHEIGHT > MAXWIDTH) ? MAXHEIGHT : MAXWIDTH)
 
 #define SIN_BUFFER_SIZE	(MAXDIMENSION+CYCLE)
diff -Naur quake_sdl/snd_dma.c quake_nacl/snd_dma.c
--- quake_sdl/snd_dma.c	2008-10-15 18:07:25.026603000 -0700
+++ quake_nacl/snd_dma.c	2009-03-02 17:15:24.839945000 -0800
@@ -8,7 +8,7 @@
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
 See the GNU General Public License for more details.
 
@@ -116,7 +116,7 @@
 		Con_Printf ("sound system not started\n");
 		return;
 	}
-	
+
     Con_Printf("%5d stereo\n", shm->channels - 1);
     Con_Printf("%5d samples\n", shm->samples);
     Con_Printf("%5d samplepos\n", shm->samplepos);
@@ -256,13 +256,13 @@
 	if (shm)
 		shm->gamealive = 0;
 
-	shm = 0;
-	sound_started = 0;
-
 	if (!fakedma)
 	{
 		SNDDMA_Shutdown();
 	}
+
+	shm = 0;
+	sound_started = 0;
 }
 
 
@@ -296,12 +296,12 @@
 
 	if (num_sfx == MAX_SFX)
 		Sys_Error ("S_FindName: out of sfx_t");
-	
+
 	sfx = &known_sfx[i];
 	strcpy (sfx->name, name);
 
 	num_sfx++;
-	
+
 	return sfx;
 }
 
@@ -315,7 +315,7 @@
 void S_TouchSound (char *name)
 {
 	sfx_t	*sfx;
-	
+
 	if (!sound_started)
 		return;
 
@@ -337,11 +337,11 @@
 		return NULL;
 
 	sfx = S_FindName (name);
-	
+
 // cache it in
 	if (precache.value)
-		S_LoadSound (sfx);
-	
+		S_LoadSound (sfx, 1);
+
 	return sfx;
 }
 
@@ -389,8 +389,8 @@
 	if (channels[first_to_die].sfx)
 		channels[first_to_die].sfx = NULL;
 
-    return &channels[first_to_die];    
-}       
+    return &channels[first_to_die];
+}
 
 /*
 =================
@@ -417,9 +417,9 @@
 
 	snd = ch->sfx;
 	VectorSubtract(ch->origin, listener_origin, source_vec);
-	
+
 	dist = VectorNormalize(source_vec) * ch->dist_mult;
-	
+
 	dot = DotProduct(listener_right, source_vec);
 
 	if (shm->channels == 1)
@@ -443,7 +443,7 @@
 	ch->leftvol = (int) (ch->master_vol * scale);
 	if (ch->leftvol < 0)
 		ch->leftvol = 0;
-}           
+}
 
 
 // =======================================================================
@@ -473,7 +473,7 @@
 	target_chan = SND_PickChannel(entnum, entchannel);
 	if (!target_chan)
 		return;
-		
+
 // spatialize
 	memset (target_chan, 0, sizeof(*target_chan));
 	VectorCopy(origin, target_chan->origin);
@@ -487,7 +487,7 @@
 		return;		// not audible at all
 
 // new channel
-	sc = S_LoadSound (sfx);
+	sc = S_LoadSound (sfx, 1);
 	if (!sc)
 	{
 		target_chan->sfx = NULL;
@@ -496,7 +496,7 @@
 
 	target_chan->sfx = sfx;
 	target_chan->pos = 0.0;
-    target_chan->end = paintedtime + sc->length;	
+    target_chan->end = paintedtime + sc->length;
 
 // if an identical sound has also been started this frame, offset the pos
 // a bit to keep it from just making the first one louder
@@ -514,7 +514,7 @@
 			target_chan->end -= skip;
 			break;
 		}
-		
+
 	}
 }
 
@@ -561,7 +561,7 @@
 void S_ClearBuffer (void)
 {
 	int		clear;
-		
+
 #ifdef _WIN32
 	if (!sound_started || !shm || (!shm->buffer && !pDSBuf))
 #else
@@ -604,7 +604,7 @@
 		Q_memset(pData, clear, shm->samples * shm->samplebits/8);
 
 		pDSBuf->lpVtbl->Unlock(pDSBuf, pData, dwSize, NULL, 0);
-	
+
 	}
 	else
 #endif
@@ -636,7 +636,7 @@
 	ss = &channels[total_channels];
 	total_channels++;
 
-	sc = S_LoadSound (sfx);
+	sc = S_LoadSound (sfx, 1);
 	if (!sc)
 		return;
 
@@ -645,13 +645,13 @@
 		Con_Printf ("Sound %s not looped\n", sfx->name);
 		return;
 	}
-	
+
 	ss->sfx = sfx;
 	VectorCopy (origin, ss->origin);
 	ss->master_vol = vol;
 	ss->dist_mult = (attenuation/64) / sound_nominal_clip_dist;
-    ss->end = paintedtime + sc->length;	
-	
+    ss->end = paintedtime + sc->length;
+
 	SND_Spatialize (ss);
 }
 
@@ -687,9 +687,9 @@
 
 	for (ambient_channel = 0 ; ambient_channel< NUM_AMBIENTS ; ambient_channel++)
 	{
-		chan = &channels[ambient_channel];	
+		chan = &channels[ambient_channel];
 		chan->sfx = ambient_sfx[ambient_channel];
-	
+
 		vol = ambient_level.value * l->ambient_sound_level[ambient_channel];
 		if (vol < 8)
 			vol = 0;
@@ -707,7 +707,7 @@
 			if (chan->master_vol < vol)
 				chan->master_vol = vol;
 		}
-		
+
 		chan->leftvol = chan->rightvol = chan->master_vol;
 	}
 }
@@ -734,13 +734,13 @@
 	VectorCopy(forward, listener_forward);
 	VectorCopy(right, listener_right);
 	VectorCopy(up, listener_up);
-	
+
 // update general area ambient sound sources
 	S_UpdateAmbientSounds ();
 
 	combine = NULL;
 
-// update spatialization for static and dynamic sounds	
+// update spatialization for static and dynamic sounds
 	ch = channels+NUM_AMBIENTS;
 	for (i=NUM_AMBIENTS ; i<total_channels; i++, ch++)
 	{
@@ -752,7 +752,7 @@
 
 	// try to combine static sounds with a previous channel of the same
 	// sound effect so we don't mix five torches every frame
-	
+
 		if (i >= MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS)
 		{
 		// see if it can just use the last one
@@ -768,7 +768,7 @@
 			for (j=MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS ; j<i; j++, combine++)
 				if (combine->sfx == ch->sfx)
 					break;
-					
+
 			if (j == total_channels)
 			{
 				combine = NULL;
@@ -784,8 +784,8 @@
 				continue;
 			}
 		}
-		
-		
+
+
 	}
 
 //
@@ -801,7 +801,7 @@
 				//Con_Printf ("%3i %3i %s\n", ch->leftvol, ch->rightvol, ch->sfx->name);
 				total++;
 			}
-		
+
 		Con_Printf ("----(%i)----\n", total);
 	}
 
@@ -815,7 +815,7 @@
 	static	int		buffers;
 	static	int		oldsamplepos;
 	int		fullsamples;
-	
+
 	fullsamples = shm->samples / shm->channels;
 
 // it is possible to miscount buffers if it has wrapped twice between
@@ -829,7 +829,7 @@
 	if (samplepos < oldsamplepos)
 	{
 		buffers++;					// buffer wrapped
-		
+
 		if (paintedtime > 0x40000000)
 		{	// time to chop things off to avoid 32 bit limits
 			buffers = 0;
@@ -861,7 +861,7 @@
 
 	unsigned        endtime;
 	int				samps;
-	
+
 	if (!sound_started || (snd_blocked > 0))
 		return;
 
@@ -890,10 +890,10 @@
 		{
 			if (pDSBuf->lpVtbl->GetStatus (pDSBuf, &dwStatus) != DD_OK)
 				Con_Printf ("Couldn't get sound buffer status\n");
-			
+
 			if (dwStatus & DSBSTATUS_BUFFERLOST)
 				pDSBuf->lpVtbl->Restore (pDSBuf);
-			
+
 			if (!(dwStatus & DSBSTATUS_PLAYING))
 				pDSBuf->lpVtbl->Play(pDSBuf, 0, 0, DSBPLAY_LOOPING);
 		}
@@ -920,7 +920,7 @@
 	int 	i;
 	char name[256];
 	sfx_t	*sfx;
-	
+
 	i = 1;
 	while (i<Cmd_Argc())
 	{
@@ -944,7 +944,7 @@
 	float vol;
 	char name[256];
 	sfx_t	*sfx;
-	
+
 	i = 1;
 	while (i<Cmd_Argc())
 	{
@@ -995,7 +995,7 @@
 		return;
 	if (!sound_started)
 		return;
-		
+
 	sfx = S_PrecacheSound (sound);
 	if (!sfx)
 	{
diff -Naur quake_sdl/snd_mem.c quake_nacl/snd_mem.c
--- quake_sdl/snd_mem.c	2008-10-15 18:07:25.043572000 -0700
+++ quake_nacl/snd_mem.c	2009-03-02 17:15:24.955951000 -0800
@@ -94,7 +94,7 @@
 S_LoadSound
 ==============
 */
-sfxcache_t *S_LoadSound (sfx_t *s)
+sfxcache_t *S_LoadSound (sfx_t *s, int main_thread)
 {
     char	namebuffer[256];
 	byte	*data;
@@ -105,7 +105,11 @@
 	byte	stackbuf[1*1024];		// avoid dirtying the cache heap
 
 // see if still in memory
-	sc = Cache_Check (&s->cache);
+	if (main_thread)
+		sc = Cache_Check (&s->cache);
+	else
+		sc = Cache_Check_Limited (&s->cache);
+
 	if (sc)
 		return sc;
 
diff -Naur quake_sdl/snd_mix.c quake_nacl/snd_mix.c
--- quake_sdl/snd_mix.c	2008-10-15 18:07:25.046569000 -0700
+++ quake_nacl/snd_mix.c	2009-03-02 17:15:24.960991000 -0800
@@ -8,7 +8,7 @@
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
 See the GNU General Public License for more details.
 
@@ -27,7 +27,7 @@
 #define DWORD	unsigned long
 #endif
 
-#define	PAINTBUFFER_SIZE	512
+#define	PAINTBUFFER_SIZE	4096
 portable_samplepair_t paintbuffer[PAINTBUFFER_SIZE];
 int		snd_scaletable[32][256];
 int 	*snd_p, snd_linear_count, snd_vol;
@@ -35,7 +35,6 @@
 
 void Snd_WriteLinearBlastStereo16 (void);
 
-#if	!id386
 void Snd_WriteLinearBlastStereo16 (void)
 {
 	int		i;
@@ -60,61 +59,28 @@
 			snd_out[i+1] = val;
 	}
 }
-#endif
+
 
 void S_TransferStereo16 (int endtime)
 {
 	int		lpos;
 	int		lpaintedtime;
 	DWORD	*pbuf;
-#ifdef _WIN32
-	int		reps;
-	DWORD	dwSize,dwSize2;
-	DWORD	*pbuf2;
-	HRESULT	hresult;
-#endif
-	
+
 	snd_vol = volume.value*256;
 
 	snd_p = (int *) paintbuffer;
 	lpaintedtime = paintedtime;
 
-#ifdef _WIN32
-	if (pDSBuf)
-	{
-		reps = 0;
-
-		while ((hresult = pDSBuf->lpVtbl->Lock(pDSBuf, 0, gSndBufSize, &pbuf, &dwSize, 
-									   &pbuf2, &dwSize2, 0)) != DS_OK)
-		{
-			if (hresult != DSERR_BUFFERLOST)
-			{
-				Con_Printf ("S_TransferStereo16: DS::Lock Sound Buffer Failed\n");
-				S_Shutdown ();
-				S_Startup ();
-				return;
-			}
-
-			if (++reps > 10000)
-			{
-				Con_Printf ("S_TransferStereo16: DS: couldn't restore buffer\n");
-				S_Shutdown ();
-				S_Startup ();
-				return;
-			}
-		}
-	}
-	else
-#endif
-	{
-		pbuf = (DWORD *)shm->buffer;
-	}
+	pbuf = (DWORD *)shm->buffer;
 
 	while (lpaintedtime < endtime)
 	{
-	// handle recirculating buffer issues
-		lpos = lpaintedtime & ((shm->samples>>1)-1);
+		// handle recirculating buffer issues
+		//lpos = lpaintedtime & ((shm->samples>>1)-1);
+		lpos = 0;
 
+		//snd_out = (short *) pbuf; // + (lpos<<1);
 		snd_out = (short *) pbuf + (lpos<<1);
 
 		snd_linear_count = (shm->samples>>1) - lpos;
@@ -123,127 +89,17 @@
 
 		snd_linear_count <<= 1;
 
-	// write a linear blast of samples
+		// write a linear blast of samples
 		Snd_WriteLinearBlastStereo16 ();
 
 		snd_p += snd_linear_count;
 		lpaintedtime += (snd_linear_count>>1);
 	}
-
-#ifdef _WIN32
-	if (pDSBuf)
-		pDSBuf->lpVtbl->Unlock(pDSBuf, pbuf, dwSize, NULL, 0);
-#endif
 }
 
 void S_TransferPaintBuffer(int endtime)
 {
-	int 	out_idx;
-	int 	count;
-	int 	out_mask;
-	int 	*p;
-	int 	step;
-	int		val;
-	int		snd_vol;
-	DWORD	*pbuf;
-#ifdef _WIN32
-	int		reps;
-	DWORD	dwSize,dwSize2;
-	DWORD	*pbuf2;
-	HRESULT	hresult;
-#endif
-
-	if (shm->samplebits == 16 && shm->channels == 2)
-	{
-		S_TransferStereo16 (endtime);
-		return;
-	}
-	
-	p = (int *) paintbuffer;
-	count = (endtime - paintedtime) * shm->channels;
-	out_mask = shm->samples - 1; 
-	out_idx = paintedtime * shm->channels & out_mask;
-	step = 3 - shm->channels;
-	snd_vol = volume.value*256;
-
-#ifdef _WIN32
-	if (pDSBuf)
-	{
-		reps = 0;
-
-		while ((hresult = pDSBuf->lpVtbl->Lock(pDSBuf, 0, gSndBufSize, &pbuf, &dwSize, 
-									   &pbuf2,&dwSize2, 0)) != DS_OK)
-		{
-			if (hresult != DSERR_BUFFERLOST)
-			{
-				Con_Printf ("S_TransferPaintBuffer: DS::Lock Sound Buffer Failed\n");
-				S_Shutdown ();
-				S_Startup ();
-				return;
-			}
-
-			if (++reps > 10000)
-			{
-				Con_Printf ("S_TransferPaintBuffer: DS: couldn't restore buffer\n");
-				S_Shutdown ();
-				S_Startup ();
-				return;
-			}
-		}
-	}
-	else
-#endif
-	{
-		pbuf = (DWORD *)shm->buffer;
-	}
-
-	if (shm->samplebits == 16)
-	{
-		short *out = (short *) pbuf;
-		while (count--)
-		{
-			val = (*p * snd_vol) >> 8;
-			p+= step;
-			if (val > 0x7fff)
-				val = 0x7fff;
-			else if (val < (short)0x8000)
-				val = (short)0x8000;
-			out[out_idx] = val;
-			out_idx = (out_idx + 1) & out_mask;
-		}
-	}
-	else if (shm->samplebits == 8)
-	{
-		unsigned char *out = (unsigned char *) pbuf;
-		while (count--)
-		{
-			val = (*p * snd_vol) >> 8;
-			p+= step;
-			if (val > 0x7fff)
-				val = 0x7fff;
-			else if (val < (short)0x8000)
-				val = (short)0x8000;
-			out[out_idx] = (val>>8) + 128;
-			out_idx = (out_idx + 1) & out_mask;
-		}
-	}
-
-#ifdef _WIN32
-	if (pDSBuf) {
-		DWORD dwNewpos, dwWrite;
-		int il = paintedtime;
-		int ir = endtime - paintedtime;
-		
-		ir += il;
-
-		pDSBuf->lpVtbl->Unlock(pDSBuf, pbuf, dwSize, NULL, 0);
-
-		pDSBuf->lpVtbl->GetCurrentPosition(pDSBuf, &dwNewpos, &dwWrite);
-
-//		if ((dwNewpos >= il) && (dwNewpos <= ir))
-//			Con_Printf("%d-%d p %d c\n", il, ir, dwNewpos);
-	}
-#endif
+	S_TransferStereo16 (endtime);
 }
 
 
@@ -270,8 +126,10 @@
 	{
 	// if paintbuffer is smaller than DMA buffer
 		end = endtime;
-		if (endtime - paintedtime > PAINTBUFFER_SIZE)
+		if (endtime - paintedtime > PAINTBUFFER_SIZE) {
 			end = paintedtime + PAINTBUFFER_SIZE;
+			Con_Printf("*************************************************Paintbuffer overflow!\n");
+		}
 
 	// clear the paint buffer
 		Q_memset(paintbuffer, 0, (end - paintedtime) * sizeof(portable_samplepair_t));
@@ -284,7 +142,7 @@
 				continue;
 			if (!ch->leftvol && !ch->rightvol)
 				continue;
-			sc = S_LoadSound (ch->sfx);
+			sc = S_LoadSound (ch->sfx, 0);
 			if (!sc)
 				continue;
 
@@ -298,12 +156,12 @@
 					count = end - ltime;
 
 				if (count > 0)
-				{	
+				{
 					if (sc->width == 1)
 						SND_PaintChannelFrom8(ch, sc, count);
 					else
 						SND_PaintChannelFrom16(ch, sc, count);
-	
+
 					ltime += count;
 				}
 
@@ -315,14 +173,14 @@
 						ch->pos = sc->loopstart;
 						ch->end = ltime + sc->length - ch->pos;
 					}
-					else				
+					else
 					{	// channel just stopped
 						ch->sfx = NULL;
 						break;
 					}
 				}
 			}
-															  
+
 		}
 
 	// transfer out according to DMA format
@@ -334,15 +192,13 @@
 void SND_InitScaletable (void)
 {
 	int		i, j;
-	
+
 	for (i=0 ; i<32 ; i++)
 		for (j=0 ; j<256 ; j++)
 			snd_scaletable[i][j] = ((signed char)j) * i * 8;
 }
 
 
-#if	!id386
-
 void SND_PaintChannelFrom8 (channel_t *ch, sfxcache_t *sc, int count)
 {
 	int 	data;
@@ -354,7 +210,7 @@
 		ch->leftvol = 255;
 	if (ch->rightvol > 255)
 		ch->rightvol = 255;
-		
+
 	lscale = snd_scaletable[ch->leftvol >> 3];
 	rscale = snd_scaletable[ch->rightvol >> 3];
 	sfx = (signed char *)sc->data + ch->pos;
@@ -365,12 +221,10 @@
 		paintbuffer[i].left += lscale[data];
 		paintbuffer[i].right += rscale[data];
 	}
-	
+
 	ch->pos += count;
 }
 
-#endif	// !id386
-
 
 void SND_PaintChannelFrom16 (channel_t *ch, sfxcache_t *sc, int count)
 {
diff -Naur quake_sdl/snd_nacl.c quake_nacl/snd_nacl.c
--- quake_sdl/snd_nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ quake_nacl/snd_nacl.c	2009-03-02 17:15:24.971943000 -0800
@@ -0,0 +1,106 @@
+#include "quakedef.h"
+#include <pthread.h>
+
+#include <stdio.h>
+//#include "SDL_audio.h"
+//#include "SDL_byteorder.h"
+
+#if defined(STANDALONE)
+#include "native_client/common/standalone.h"
+#else
+#include <nacl/nacl_av.h>
+#endif
+
+static dma_t the_shm;
+volatile int snd_thread_running = 0;
+volatile int paint_audio_thread_exited = 0;
+static pthread_t snd_thread_id = 0;
+
+void* nacl_paint_audio_thread(void *userdata) {
+unsigned char buffer[32 * 1024];
+int count = 0;
+int rval = 0;
+	paint_audio_thread_exited = 0;
+	while(rval == 0) {
+		volatile dma_t *cshm = shm;
+		if (cshm) {
+			rval = nacl_audio_stream(buffer, &count);
+			cshm->buffer = buffer;
+			cshm->samplepos += count/(cshm->samplebits/8)/2;
+			S_PaintChannels (cshm->samplepos);
+		}
+		if (0 == snd_thread_running) break;
+	}
+	paint_audio_thread_exited = 1;
+}
+
+
+qboolean SNDDMA_Init(void)
+{
+	#define AUDIO_S16LSB 0x8010
+	int audio_freq = 44100;
+	int audio_samples = 4096;
+	int audio_format = AUDIO_S16LSB;
+	int audio_channels = 2;
+	int obtained_samples;
+	extern volatile dma_t *shm;
+
+	/* Set up the desired format */
+	shm = NULL;
+	snd_thread_running = 1;
+
+	/* create audio thread */
+	Con_Printf("Spawning audio thread...\n");
+	int p = pthread_create(&snd_thread_id, NULL, nacl_paint_audio_thread, NULL);
+	if (0 != p) {
+		Con_Printf("Unable to create audio thread!\n");
+		snd_thread_running = 0;
+		return 0;
+	}
+	Con_Printf("...done spawning pthread!\n");
+
+
+	Con_Printf("Audio requested %d samples\n", audio_samples);
+
+	/* Open the audio device */
+	if ( nacl_audio_init(NACL_AUDIO_FORMAT_STEREO_44K, audio_samples, &obtained_samples) < 0 ) {
+        	Con_Printf("Couldn't init nacl audio\n");
+		snd_thread_running = 0;
+		return 0;
+	}
+
+	audio_samples = obtained_samples;
+
+	Con_Printf("Audio obtained %d samples\n", audio_samples);
+
+	/* Fill the audio DMA information block */
+	the_shm.splitbuffer = 0;
+	the_shm.samplebits = (audio_format & 0xFF);
+	the_shm.speed = audio_freq;
+	the_shm.channels = audio_channels;
+	the_shm.samples = audio_samples * the_shm.channels;
+	the_shm.samplepos = 0;
+	the_shm.submission_chunk = 1;
+	the_shm.buffer = NULL;
+
+	/* activate */
+	shm = &the_shm;
+
+	return 1;
+}
+
+int SNDDMA_GetDMAPos(void)
+{
+	return shm->samplepos;
+}
+
+void SNDDMA_Shutdown(void)
+{
+	if (snd_thread_running)
+	{
+		snd_thread_running = 0;
+		nacl_audio_shutdown();
+		while (paint_audio_thread_exited == 0)
+			sched_yield();
+	}
+}
diff -Naur quake_sdl/sound.h quake_nacl/sound.h
--- quake_sdl/sound.h	2008-10-15 18:07:37.102562000 -0700
+++ quake_nacl/sound.h	2009-03-02 17:15:26.042835000 -0800
@@ -164,7 +164,7 @@
 extern int		snd_blocked;
 
 void S_LocalSound (char *s);
-sfxcache_t *S_LoadSound (sfx_t *s);
+sfxcache_t *S_LoadSound (sfx_t *s, int main_thread);
 
 wavinfo_t GetWavinfo (char *name, byte *wav, int wavlength);
 
diff -Naur quake_sdl/sys_nacl.c quake_nacl/sys_nacl.c
--- quake_sdl/sys_nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ quake_nacl/sys_nacl.c	2009-03-02 17:15:25.051911000 -0800
@@ -0,0 +1,429 @@
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#ifndef __WIN32__
+//#include <sys/ipc.h>
+//#include <sys/shm.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+//#include <sys/mman.h>
+#endif
+#if defined(STANDALONE)
+#include "../../common/standalone.h"
+#else
+#include <nacl/nacl_av.h>
+#include <nacl/nacl_srpc.h>
+#include <sys/nacl_syscalls.h>
+#endif
+
+#include "quakedef.h"
+
+//#define HAVE_MKDIR
+
+qboolean			isDedicated;
+
+int noconinput = 0;
+
+char *basedir = ".";
+char *cachedir = "";
+
+cvar_t  sys_linerefresh = {"sys_linerefresh","0"};// set for entity display
+cvar_t  sys_nostdout = {"sys_nostdout","0"};
+
+// =======================================================================
+// General routines
+// =======================================================================
+
+void Sys_DebugNumber(int y, int val)
+{
+}
+
+void Sys_Printf (char *fmt, ...)
+{
+	va_list		argptr;
+	char		text[1024];
+
+	va_start (argptr,fmt);
+	vsprintf (text,fmt,argptr);
+	va_end (argptr);
+	fprintf(stderr, "%s", text);
+
+	//Con_Print (text);
+}
+
+void Sys_Quit (void)
+{
+	Host_Shutdown();
+	exit(0);
+}
+
+void Sys_Init(void)
+{
+#if id386
+	Sys_SetFPCW();
+#endif
+}
+
+#if !id386
+
+/*
+================
+Sys_LowFPPrecision
+================
+*/
+void Sys_LowFPPrecision (void)
+{
+// causes weird problems on Nextstep
+}
+
+
+/*
+================
+Sys_HighFPPrecision
+================
+*/
+void Sys_HighFPPrecision (void)
+{
+// causes weird problems on Nextstep
+}
+
+#endif	// !id386
+
+
+void Sys_Error (char *error, ...)
+{
+    va_list     argptr;
+    char        string[1024];
+
+    va_start (argptr,error);
+    vsprintf (string,error,argptr);
+    va_end (argptr);
+	fprintf(stderr, "Error: %s\n", string);
+
+	Host_Shutdown ();
+	exit (1);
+
+}
+
+void Sys_Warn (char *warning, ...)
+{
+    va_list     argptr;
+    char        string[1024];
+
+    va_start (argptr,warning);
+    vsprintf (string,warning,argptr);
+    va_end (argptr);
+	fprintf(stderr, "Warning: %s", string);
+}
+
+/*
+===============================================================================
+
+FILE IO
+
+===============================================================================
+*/
+
+#define	MAX_HANDLES		10
+FILE	*sys_handles[MAX_HANDLES];
+
+int		findhandle (void)
+{
+	int		i;
+
+	for (i=1 ; i<MAX_HANDLES ; i++)
+		if (!sys_handles[i])
+			return i;
+	Sys_Error ("out of handles");
+	return -1;
+}
+
+/*
+================
+Qfilelength
+================
+*/
+static int Qfilelength (FILE *f)
+{
+	int		pos;
+	int		end;
+
+	pos = ftell (f);
+	fseek (f, 0, SEEK_END);
+	end = ftell (f);
+	fseek (f, pos, SEEK_SET);
+
+	return end;
+}
+
+int Sys_FileOpenRead (char *path, int *hndl)
+{
+	FILE	*f;
+	int		i;
+
+	i = findhandle ();
+
+	f = fopen(path, "rb");
+	if (!f)
+	{
+		*hndl = -1;
+		return -1;
+	}
+	sys_handles[i] = f;
+	*hndl = i;
+
+	return Qfilelength(f);
+}
+
+int Sys_FileOpenWrite (char *path)
+{
+	FILE	*f;
+	int		i;
+
+	i = findhandle ();
+
+	f = fopen(path, "wb");
+	if (!f)
+		Sys_Error ("Error opening %s: %s", path,strerror(errno));
+	sys_handles[i] = f;
+
+	return i;
+}
+
+void Sys_FileClose (int handle)
+{
+	if ( handle >= 0 ) {
+		fclose (sys_handles[handle]);
+		sys_handles[handle] = NULL;
+	}
+}
+
+void Sys_FileSeek (int handle, int position)
+{
+	if ( handle >= 0 ) {
+		fseek (sys_handles[handle], position, SEEK_SET);
+	}
+}
+
+int Sys_FileRead (int handle, void *dst, int count)
+{
+	char *data;
+	int size, done;
+
+	size = 0;
+	if ( handle >= 0 ) {
+		data = dst;
+		while ( count > 0 ) {
+			done = fread (data, 1, count, sys_handles[handle]);
+			if ( done == 0 ) {
+				break;
+			}
+			data += done;
+			count -= done;
+			size += done;
+		}
+	}
+	return size;
+
+}
+
+int Sys_FileWrite (int handle, void *src, int count)
+{
+	char *data;
+	int size, done;
+
+	size = 0;
+	if ( handle >= 0 ) {
+		data = src;
+		while ( count > 0 ) {
+			done = fread (data, 1, count, sys_handles[handle]);
+			if ( done == 0 ) {
+				break;
+			}
+			data += done;
+			count -= done;
+			size += done;
+		}
+	}
+	return size;
+}
+
+int	Sys_FileTime (char *path)
+{
+	FILE	*f;
+
+	f = fopen(path, "rb");
+	if (f)
+	{
+		fclose(f);
+		return 1;
+	}
+
+	return -1;
+}
+
+void Sys_mkdir (char *path)
+{
+#if defined (HAVE_MKDIR)
+    mkdir (path, 0777);
+#else
+    Sys_Warn("NaCl cannot mkdir('%s')\n", path);
+#endif
+}
+
+void Sys_DebugLog(char *file, char *fmt, ...)
+{
+    va_list argptr;
+    static char data[1024];
+    FILE *fp;
+
+    va_start(argptr, fmt);
+    vsprintf(data, fmt, argptr);
+    va_end(argptr);
+    fp = fopen(file, "a");
+    fwrite(data, strlen(data), 1, fp);
+    fclose(fp);
+}
+
+double Sys_FloatTime (void)
+{
+    struct timeval tp;
+    struct timezone tzp;
+    static int      secbase;
+
+    gettimeofday(&tp, &tzp);
+
+    if (!secbase)
+    {
+        secbase = tp.tv_sec;
+        return tp.tv_usec/1000000.0;
+    }
+
+    return (tp.tv_sec - secbase) + tp.tv_usec/1000000.0;
+}
+
+// =======================================================================
+// Sleeps for microseconds
+// =======================================================================
+
+static volatile int oktogo;
+
+void alarm_handler(int x)
+{
+	oktogo=1;
+}
+
+byte *Sys_ZoneBase (int *size)
+{
+
+	char *QUAKEOPT = getenv("QUAKEOPT");
+
+	*size = 0xc00000;
+	if (QUAKEOPT)
+	{
+		while (*QUAKEOPT)
+			if (tolower(*QUAKEOPT++) == 'm')
+			{
+				*size = atof(QUAKEOPT) * 1024*1024;
+				break;
+			}
+	}
+	return malloc (*size);
+
+}
+
+void Sys_LineRefresh(void)
+{
+}
+
+void Sys_Sleep(void)
+{
+	extern int sched_yield(void);
+	sched_yield();
+}
+
+void floating_point_exception_handler(int whatever)
+{
+//	Sys_Warn("floating point exception\n");
+	signal(SIGFPE, floating_point_exception_handler);
+}
+
+void moncontrol(int x)
+{
+}
+
+int main (int c, char **v)
+{
+
+	double		time, oldtime, newtime;
+	quakeparms_t parms;
+	extern int vcrFile;
+	extern int recording;
+	static int frame;
+
+	moncontrol(0);
+
+//	signal(SIGFPE, floating_point_exception_handler);
+	signal(SIGFPE, SIG_IGN);
+
+	nacl_multimedia_init(NACL_SUBSYSTEM_AUDIO | NACL_SUBSYSTEM_VIDEO |
+			     NACL_SUBSYSTEM_EMBED);
+
+	parms.memsize = 32*1024*1024;
+	parms.membase = malloc (parms.memsize);
+	parms.basedir = basedir;
+	parms.cachedir = cachedir;
+
+	COM_InitArgv(c, v);
+	parms.argc = com_argc;
+	parms.argv = com_argv;
+
+	Sys_Init();
+
+    Host_Init(&parms);
+
+	Cvar_RegisterVariable (&sys_nostdout);
+
+    oldtime = Sys_FloatTime () - 0.1;
+    while (1)
+    {
+// find time spent rendering last frame
+        newtime = Sys_FloatTime ();
+        time = newtime - oldtime;
+
+        if (cls.state == ca_dedicated)
+        {   // play vcrfiles at max speed
+            if (time < sys_ticrate.value && (vcrFile == -1 || recording) )
+            {
+                Sys_Sleep ();
+                continue;       // not time to run a server only tic yet
+            }
+            time = sys_ticrate.value;
+        }
+
+        if (time > sys_ticrate.value*2)
+            oldtime = newtime;
+        else
+            oldtime += time;
+
+        if (++frame > 10)
+            moncontrol(1);      // profile only while we do each Quake frame
+        Host_Frame (time);
+        moncontrol(0);
+
+// graphic debugging aids
+        if (sys_linerefresh.value)
+            Sys_LineRefresh ();
+    }
+
+}
diff -Naur quake_sdl/sys_sdl.c quake_nacl/sys_sdl.c
--- quake_sdl/sys_sdl.c	2008-10-15 18:07:25.090565000 -0700
+++ quake_nacl/sys_sdl.c	2009-03-02 17:15:25.077891000 -0800
@@ -12,21 +12,24 @@
 #include <ctype.h>
 #include <errno.h>
 #ifndef __WIN32__
-#include <sys/ipc.h>
-#include <sys/shm.h>
+//#include <sys/ipc.h>
+//#include <sys/shm.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
-#include <sys/mman.h>
+//#include <sys/mman.h>
 #endif
 
 #include "quakedef.h"
 
+//#define HAVE_SDL_DELAY
+//#define HAVE_MKDIR
+
 qboolean			isDedicated;
 
 int noconinput = 0;
 
 char *basedir = ".";
-char *cachedir = "/tmp";
+char *cachedir = "";
 
 cvar_t  sys_linerefresh = {"sys_linerefresh","0"};// set for entity display
 cvar_t  sys_nostdout = {"sys_nostdout","0"};
@@ -265,11 +268,15 @@
 
 void Sys_mkdir (char *path)
 {
+#if defined (HAVE_MKDIR)
+
 #ifdef __WIN32__
     mkdir (path);
 #else
     mkdir (path, 0777);
 #endif
+
+#endif
 }
 
 void Sys_DebugLog(char *file, char *fmt, ...)
@@ -352,7 +359,14 @@
 
 void Sys_Sleep(void)
 {
+#if defined(HAVE_SDL_DELAY)
 	SDL_Delay(1);
+#else
+        {
+          int i;
+	  for (i = 0; i < 10000; i++) ;
+        }
+#endif
 }
 
 void floating_point_exception_handler(int whatever)
@@ -379,7 +393,7 @@
 //	signal(SIGFPE, floating_point_exception_handler);
 	signal(SIGFPE, SIG_IGN);
 
-	parms.memsize = 8*1024*1024;
+	parms.memsize = 32*1024*1024;
 	parms.membase = malloc (parms.memsize);
 	parms.basedir = basedir;
 	parms.cachedir = cachedir;
@@ -405,7 +419,7 @@
         {   // play vcrfiles at max speed
             if (time < sys_ticrate.value && (vcrFile == -1 || recording) )
             {
-                SDL_Delay (1);
+                Sys_Sleep ();
                 continue;       // not time to run a server only tic yet
             }
             time = sys_ticrate.value;
@@ -429,11 +443,18 @@
 }
 
 
+#if 0
+
+/*
+ * we certainly can't have this in NaCl(!)  Fortunately it doesn't appear to be used anymore.
+ */
+
 /*
 ================
 Sys_MakeCodeWriteable
 ================
 */
+
 void Sys_MakeCodeWriteable (unsigned long startaddr, unsigned long length)
 {
 
@@ -452,3 +473,4 @@
 
 }
 
+#endif
\ No newline at end of file
diff -Naur quake_sdl/vid_nacl.c quake_nacl/vid_nacl.c
--- quake_sdl/vid_nacl.c	1969-12-31 16:00:00.000000000 -0800
+++ quake_nacl/vid_nacl.c	2009-03-02 17:15:25.198863000 -0800
@@ -0,0 +1,427 @@
+// vid_sdl.h -- sdl video driver
+
+#include "quakedef.h"
+#include "d_local.h"
+
+#if defined(STANDALONE)
+#include "native_client/common/standalone.h"
+#else
+#include <nacl/nacl_av.h>
+#endif
+
+viddef_t    vid;                // global video state
+unsigned short  d_8to16table[256];
+
+// default resolution
+int BASEWIDTH = 800;
+int BASEHEIGHT = 600;
+
+// remap table for emulating palettes
+unsigned int gPalette[256];
+#define MAKE_RGBA(r, g, b, a) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b))
+
+int    VGA_width, VGA_height, VGA_rowbytes, VGA_bufferrowbytes = 0;
+byte    *VGA_pagebase;
+
+struct NACL_Color
+{
+  char r;
+  char g;
+  char b;
+  char unused;
+};
+
+struct NACL_Surface
+{
+  int w;
+  int h;
+  int pitch;
+  int flags;
+  void *pixels;
+  struct NACL_Color palette[256];
+};
+
+
+static struct NACL_Surface *screen = NULL;
+static unsigned int *pixels32 = NULL;
+
+static qboolean mouse_avail;
+static float   mouse_x, mouse_y;
+static int mouse_oldbuttonstate = 0;
+
+// No support for option menus
+void (*vid_menudrawfn)(void) = NULL;
+void (*vid_menukeyfn)(int key) = NULL;
+
+void    VID_SetPalette (unsigned char *palette)
+{
+    int i;
+    /* emulate palette in software */
+    if (screen) {
+          struct NACL_Color *screen_colors = screen->palette;
+          for ( i = 0; i < 256; ++i ) {
+              screen_colors[i].r = *palette++;
+              screen_colors[i].g = *palette++;
+              screen_colors[i].b = *palette++;
+              screen_colors[i].unused = 255;
+          }
+    }
+}
+
+void    VID_ShiftPalette (unsigned char *palette)
+{
+    VID_SetPalette(palette);
+}
+
+void    VID_Init (unsigned char *palette)
+{
+    int pnum, chunk;
+    byte *cache;
+    int cachesize;
+    unsigned char video_bpp;
+    unsigned short video_w, video_h;
+    unsigned int flags;
+
+    // if this call succeeds, use width & height from embedded html
+    {
+      int width;
+      int height;
+      int r = nacl_multimedia_get_embed_size(&width, &height);
+      if (0 == r) {
+          BASEWIDTH = width;
+          BASEHEIGHT = height;
+      }
+    }
+
+    // Set up display mode (width and height)
+    vid.width = BASEWIDTH;
+    vid.height = BASEHEIGHT;
+    vid.maxwarpwidth = WARP_WIDTH;
+    vid.maxwarpheight = WARP_HEIGHT;
+    nacl_video_init(vid.width, vid.height);
+
+    // Set up a fake 8bit 'screen' that quake will draw into
+    // It will be our job to manually blit 8bit -> 32bit
+    screen = malloc(sizeof(struct NACL_Surface));
+    memset(screen, 0, sizeof(struct NACL_Surface));
+    screen->flags = 0;
+    screen->w = BASEWIDTH;
+    screen->h = BASEHEIGHT;
+    screen->pitch = BASEWIDTH;
+    screen->pixels = malloc(BASEWIDTH * BASEHEIGHT * sizeof(byte));
+    memset(screen->pixels, 0, BASEWIDTH * BASEHEIGHT * sizeof(byte));
+
+    // Set up a staging area of 32bit pixels that we'll use to up-convert
+    // (in theory we could use SDL to do this, but we'd have to expose
+    // more of the SDL API via trampoline)
+    pixels32 = malloc(BASEWIDTH * BASEHEIGHT * sizeof(unsigned int));
+
+    VID_SetPalette(palette);
+
+    // now know everything we need to know about the buffer
+    VGA_width = vid.conwidth = vid.width;
+    VGA_height = vid.conheight = vid.height;
+    vid.aspect = ((float)vid.height / (float)vid.width) * (320.0 / 240.0);
+    vid.numpages = 1;
+    vid.colormap = host_colormap;
+    vid.fullbright = 256 - LittleLong (*((int *)vid.colormap + 2048));
+    VGA_pagebase = vid.buffer = screen->pixels;
+    VGA_rowbytes = vid.rowbytes = screen->pitch;
+    vid.conbuffer = vid.buffer;
+    vid.conrowbytes = vid.rowbytes;
+    vid.direct = 0;
+
+    // allocate z buffer and surface cache
+    chunk = vid.width * vid.height * sizeof (*d_pzbuffer);
+    cachesize = D_SurfaceCacheForRes (vid.width, vid.height);
+    chunk += cachesize;
+    d_pzbuffer = Hunk_HighAllocName(chunk, "video");
+    if (d_pzbuffer == NULL)
+        Sys_Error ("Not enough memory for video mode\n");
+
+    // initialize the cache memory
+        cache = (byte *) d_pzbuffer
+                + vid.width * vid.height * sizeof (*d_pzbuffer);
+    D_InitCaches (cache, cachesize);
+}
+
+static void VID_FreeSurface(struct NACL_Surface *surf) {
+  if (NULL != surf) {
+    if (surf->pixels) {
+      free(surf->pixels);
+    }
+    free(surf);
+  }
+}
+
+void    VID_Shutdown (void)
+{
+    VID_FreeSurface(screen);
+    if (pixels32) {
+      free(pixels32);
+    }
+    screen = NULL;
+    pixels32 = NULL;
+    nacl_video_shutdown();
+    nacl_multimedia_shutdown();
+}
+
+static void UpdateAll() {
+  // just copy the whole darn thing
+  int i;
+  byte *src = screen->pixels;
+  unsigned int *dst = pixels32;
+  unsigned int colors[256];
+  // convert palette to our real screen format
+  for (i = 0; i < 256; ++i) {
+    byte r = screen->palette[i].r;
+    byte g = screen->palette[i].g;
+    byte b = screen->palette[i].b;
+    byte a = 255;
+    colors[i] = MAKE_RGBA(r, g, b, a);
+  }
+  // convert quake's 8bit output to 32bit raw bgra pixel data
+  for (i = 0; i < screen->w * screen->h; ++i) {
+    byte b = *src++;
+    unsigned int c = colors[b];
+    *dst++ = c;
+  }
+  // call SDL via trampoline with raw bgra pixel data
+  nacl_video_update(pixels32);
+}
+
+void    VID_Update (vrect_t *rects)
+{
+    UpdateAll();
+}
+
+/*
+================
+D_BeginDirectRect
+================
+*/
+void D_BeginDirectRect (int x, int y, byte *pbitmap, int width, int height)
+{
+    unsigned char *offset;
+
+
+    if (!screen) return;
+    if ( x < 0 ) x = screen->w+x-1;
+    offset = (unsigned char *)screen->pixels + y*screen->pitch + x;
+    while ( height-- )
+    {
+        memcpy(offset, pbitmap, width);
+        offset += screen->pitch;
+        pbitmap += width;
+    }
+}
+
+
+/*
+================
+D_EndDirectRect
+================
+*/
+void D_EndDirectRect (int x, int y, int width, int height)
+{
+    if (!screen) return;
+    if (x < 0) x = screen->w+x-1;
+    // update the whole screen
+    UpdateAll();
+}
+
+
+/*
+================
+Sys_SendKeyEvents
+================
+*/
+
+void Sys_SendKeyEvents(void)
+{
+    union NaClMultimediaEvent event;
+    int sym, state;
+    int modstate;
+    while (0 == nacl_video_poll_event(&event))
+    {
+        switch (event.type) {
+
+            case NACL_EVENT_KEY_DOWN:
+            case NACL_EVENT_KEY_UP:
+                sym = event.key.keysym.sym;
+                state = event.key.state;
+                modstate = event.key.keysym.mod;
+
+                //printf("sym: %d, state: %d, modstate: %d\n", sym, state, modstate);
+                //printf("up: %d, down: %d, left: %d, right: %d\n", NACL_KEY_UP, NACL_KEY_DOWN, NACL_KEY_LEFT, NACL_KEY_RIGHT);
+
+                switch(sym)
+                {
+                   case NACL_KEY_DELETE: sym = K_DEL; break;
+                   case NACL_KEY_BACKSPACE: sym = K_BACKSPACE; break;
+                   case NACL_KEY_F1: sym = K_F1; break;
+                   case NACL_KEY_F2: sym = K_F2; break;
+                   case NACL_KEY_F3: sym = K_F3; break;
+                   case NACL_KEY_F4: sym = K_F4; break;
+                   case NACL_KEY_F5: sym = K_F5; break;
+                   case NACL_KEY_F6: sym = K_F6; break;
+                   case NACL_KEY_F7: sym = K_F7; break;
+                   case NACL_KEY_F8: sym = K_F8; break;
+                   case NACL_KEY_F9: sym = K_F9; break;
+                   case NACL_KEY_F10: sym = K_F10; break;
+                   case NACL_KEY_F11: sym = K_F11; break;
+                   case NACL_KEY_F12: sym = K_F12; break;
+                   case NACL_KEY_BREAK:
+                   case NACL_KEY_PAUSE: sym = K_PAUSE; break;
+                   case NACL_KEY_UP: sym = K_UPARROW; break;
+                   case NACL_KEY_DOWN: sym = K_DOWNARROW; break;
+                   case NACL_KEY_RIGHT: sym = K_RIGHTARROW; break;
+                   case NACL_KEY_LEFT: sym = K_LEFTARROW; break;
+                   case NACL_KEY_INSERT: sym = K_INS; break;
+                   case NACL_KEY_HOME: sym = K_HOME; break;
+                   case NACL_KEY_END: sym = K_END; break;
+                   case NACL_KEY_PAGEUP: sym = K_PGUP; break;
+                   case NACL_KEY_PAGEDOWN: sym = K_PGDN; break;
+                   case NACL_KEY_RSHIFT:
+                   case NACL_KEY_LSHIFT: sym = K_SHIFT; break;
+                   case NACL_KEY_RCTRL:
+                   case NACL_KEY_LCTRL: sym = K_CTRL; break;
+                   case NACL_KEY_RALT:
+                   case NACL_KEY_LALT: sym = K_ALT; break;
+                   case NACL_KEY_KP0:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_INS;
+                       else sym = NACL_KEY_0;
+                       break;
+                   case NACL_KEY_KP1:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_END;
+                       else sym = NACL_KEY_1;
+                       break;
+                   case NACL_KEY_KP2:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_DOWNARROW;
+                       else sym = NACL_KEY_2;
+                       break;
+                   case NACL_KEY_KP3:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_PGDN;
+                       else sym = NACL_KEY_3;
+                       break;
+                   case NACL_KEY_KP4:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_LEFTARROW;
+                       else sym = NACL_KEY_4;
+                       break;
+                   case NACL_KEY_KP5: sym = NACL_KEY_5; break;
+                   case NACL_KEY_KP6:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_RIGHTARROW;
+                       else sym = NACL_KEY_6;
+                       break;
+                   case NACL_KEY_KP7:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_HOME;
+                       else sym = NACL_KEY_7;
+                       break;
+                   case NACL_KEY_KP8:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_UPARROW;
+                       else sym = NACL_KEY_8;
+                       break;
+                   case NACL_KEY_KP9:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_PGUP;
+                       else sym = NACL_KEY_9;
+                       break;
+                   case NACL_KEY_KP_PERIOD:
+                       if(modstate & NACL_KEYMOD_NUM) sym = K_DEL;
+                       else sym = NACL_KEY_PERIOD;
+                       break;
+                   case NACL_KEY_KP_DIVIDE: sym = NACL_KEY_SLASH; break;
+                   case NACL_KEY_KP_MULTIPLY: sym = NACL_KEY_ASTERISK; break;
+                   case NACL_KEY_KP_MINUS: sym = NACL_KEY_MINUS; break;
+                   case NACL_KEY_KP_PLUS: sym = NACL_KEY_PLUS; break;
+                   case NACL_KEY_KP_ENTER: sym = NACL_KEY_RETURN; break;
+                   case NACL_KEY_KP_EQUALS: sym = NACL_KEY_EQUALS; break;
+                }
+                // If we're not directly handled and still above 255
+                // just force it to 0
+                if(sym > 255) sym = 0;
+                Key_Event(sym, state);
+                break;
+
+            case NACL_EVENT_MOUSE_MOTION:
+                if ( (event.motion.x != (vid.width/2)) ||
+                     (event.motion.y != (vid.height/2)) ) {
+                    mouse_x = event.motion.xrel*10;
+                    mouse_y = event.motion.yrel*10;
+                    if ( (event.motion.x < ((vid.width/2)-(vid.width/4))) ||
+                         (event.motion.x > ((vid.width/2)+(vid.width/4))) ||
+                         (event.motion.y < ((vid.height/2)-(vid.height/4))) ||
+                         (event.motion.y > ((vid.height/2)+(vid.height/4))) ) {
+                        /* NaCl has no equivalent to:                */
+                        /* SDL_WarpMouse(vid.width/2, vid.height/2); */
+                    }
+                }
+                break;
+
+            case NACL_EVENT_QUIT:
+                CL_Disconnect ();
+                Host_ShutdownServer(false);
+                Sys_Quit ();
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void IN_Init (void)
+{
+    if ( COM_CheckParm ("-nomouse") )
+        return;
+    mouse_x = mouse_y = 0.0;
+    mouse_avail = 1;
+}
+
+void IN_Shutdown (void)
+{
+    mouse_avail = 0;
+}
+
+void IN_Commands (void)
+{
+    /* mouse events are processed in the event loop */
+}
+
+void IN_Move (usercmd_t *cmd)
+{
+    if (!mouse_avail)
+        return;
+
+    mouse_x *= sensitivity.value;
+    mouse_y *= sensitivity.value;
+
+    if ( (in_strafe.state & 1) || (lookstrafe.value && (in_mlook.state & 1) ))
+        cmd->sidemove += m_side.value * mouse_x;
+    else
+        cl.viewangles[YAW] -= m_yaw.value * mouse_x;
+    if (in_mlook.state & 1)
+        V_StopPitchDrift ();
+
+    if ( (in_mlook.state & 1) && !(in_strafe.state & 1)) {
+        cl.viewangles[PITCH] += m_pitch.value * mouse_y;
+        if (cl.viewangles[PITCH] > 80)
+            cl.viewangles[PITCH] = 80;
+        if (cl.viewangles[PITCH] < -70)
+            cl.viewangles[PITCH] = -70;
+    } else {
+        if ((in_strafe.state & 1) && noclip_anglehack)
+            cmd->upmove -= m_forward.value * mouse_y;
+        else
+            cmd->forwardmove -= m_forward.value * mouse_y;
+    }
+    mouse_x = mouse_y = 0.0;
+}
+
+/*
+================
+Sys_ConsoleInput
+================
+*/
+char *Sys_ConsoleInput (void)
+{
+    return 0;
+}
diff -Naur quake_sdl/zone.c quake_nacl/zone.c
--- quake_sdl/zone.c	2008-10-15 18:07:25.148579000 -0700
+++ quake_nacl/zone.c	2009-03-02 17:15:25.377877000 -0800
@@ -865,6 +865,17 @@
 
 /*
 ==============
+Cache_Check_Limited
+==============
+*/
+void *Cache_Check_Limited (cache_user_t *c)
+{
+	return c->data;
+}
+
+
+/*
+==============
 Cache_Alloc
 ==============
 */
diff -Naur quake_sdl/zone.h quake_nacl/zone.h
--- quake_sdl/zone.h	2008-10-15 18:07:37.138567000 -0700
+++ quake_nacl/zone.h	2009-03-02 17:15:26.208798000 -0800
@@ -119,6 +119,9 @@
 // returns the cached data, and moves to the head of the LRU list
 // if present, otherwise returns NULL
 
+void *Cache_Check_Limited (cache_user_t *c);
+// returns the cached data, if preset, otherwise returns NULL
+
 void Cache_Free (cache_user_t *c);
 
 void *Cache_Alloc (cache_user_t *c, int size, char *name);
